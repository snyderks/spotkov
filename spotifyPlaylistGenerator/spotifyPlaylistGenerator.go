package spotifyPlaylistGenerator

import (
	"fmt"
	"sync"
	"time"

	"github.com/snyderks/spotkov/lastFm"
	"github.com/zmb3/spotify"
)

const playlistName = "Generated by Spotkov"
const maxSongLength = 50

var songsWg sync.WaitGroup

func CreatePlaylist(songs []lastFm.Song, client *spotify.Client, userId string) {
	playlistsPage, err := client.GetPlaylistsForUser(userId)
	playlistExists := false
	var playlistId spotify.ID
	if err == nil {
		playlists := playlistsPage.Playlists
		for _, playlist := range playlists {
			if playlist.Name == playlistName {
				playlistId = playlist.ID
				playlistExists = true
				break
			}
		}
		if playlistExists == false {
			playlistCreated, err := client.CreatePlaylistForUser(userId, playlistName, false)
			if err != nil {
				panic(err)
			}
			playlistId = playlistCreated.SimplePlaylist.ID
		}
	} else {
		return
	}
	// retrieve tracklist async
	tracks := make([]spotify.ID, len(songs))
	for i, song := range songs {
		query := "track:" + song.Title + " artist:" + song.Artist
		songsWg.Add(1)
		go searchAndAddTrackToList(client, query, tracks, i)
	}
	songsWg.Wait()
	tracks = clearFailuresFromList(tracks)
	if len(tracks) <= maxSongLength {
		err := client.ReplacePlaylistTracks(userId, playlistId, tracks...)
		if err != nil {
			panic(err)
		}
		fmt.Println("Successfully created the playlist under the name", playlistName)
	} else {
		chunks := len(tracks)/maxSongLength + 1
		trackChunks := make([][]spotify.ID, 0)
		for i := 0; i < chunks; i++ {
			if maxSongLength*(i+1) > len(tracks) {
				trackChunks = append(trackChunks, tracks[maxSongLength*i:])
			} else {
				trackChunks = append(trackChunks, tracks[maxSongLength*i:maxSongLength*(i+1)])
			}
		}
		for i, trackChunk := range trackChunks {
			if i == 0 {
				err := client.ReplacePlaylistTracks(userId, playlistId, trackChunk...)
				for err != nil {
					time.Sleep(500 * time.Millisecond)
					err = client.ReplacePlaylistTracks(userId, playlistId, trackChunk...)
				}
			} else {
				_, err := client.AddTracksToPlaylist(userId, playlistId, trackChunk...)
				for err != nil {
					time.Sleep(500 * time.Millisecond)
					_, err = client.AddTracksToPlaylist(userId, playlistId, trackChunk...)
				}
			}
		}
		fmt.Println("Successfully created the playlist under the name", playlistName)
	}

}

func searchAndAddTrackToList(client *spotify.Client, searchQuery string, tracks []spotify.ID, index int) {
	defer songsWg.Done()
	limit := 1
	options := spotify.Options{Limit: &limit}
	results, err := client.SearchOpt(searchQuery, spotify.SearchTypeTrack, &options)
	for err != nil {
		time.Sleep(250 * time.Millisecond)
		results, err = client.SearchOpt(searchQuery, spotify.SearchTypeTrack, &options)
	}
	resultTracks := results.Tracks.Tracks
	if len(resultTracks) > 0 {
		trackId := resultTracks[0].ID
		tracks[index] = trackId
	}
}

func clearFailuresFromList(list []spotify.ID) []spotify.ID {
	newList := make([]spotify.ID, 0, len(list))
	for _, id := range list {
		if id != "" {
			newList = append(newList, id)
		}
	}
	return newList
}
