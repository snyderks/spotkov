package spotifyPlaylistGenerator

import (
  "github.com/snyderks/spotkov/lastFm"
  "github.com/zmb3/spotify"
  "sync"
  "fmt"
)

const playlistName = "Generated by Spotkov"

var songsWg sync.WaitGroup

func CreatePlaylist(songs []lastFm.Song, client *spotify.Client, userId string) {
  playlistsPage, err := client.GetPlaylistsForUser(userId)
  playlistExists := false
  var playlistId spotify.ID
  if err == nil {
    playlists := playlistsPage.Playlists
    for _, playlist := range playlists {
      if playlist.Name == playlistName {
        playlistId = playlist.ID
        playlistExists = true
        break
      }
    }
    if playlistExists == false {
      playlistCreated, err := client.CreatePlaylistForUser(userId, playlistName, false)
      if err != nil {
        panic(err)
      }
      playlistId = playlistCreated.SimplePlaylist.ID
    }
  } else {
    return
  }
  if len(songs) <= 100 {
    tracks := make([]spotify.ID, len(songs))
    for i, song := range songs {
      query := "track:" + song.Title + " artist:" + song.Artist
      songsWg.Add(1)
      go searchAndAddTrackToList(client, query, tracks, i)
    }
    songsWg.Wait()
    err := client.ReplacePlaylistTracks(userId, playlistId, clearFailuresFromList(tracks)...)
    if err != nil {
      panic(err)
    }
    fmt.Println("Successfully created the playlist under the name", playlistName)
  }

}

func searchAndAddTrackToList(client *spotify.Client, searchQuery string, tracks []spotify.ID, index int) {
  defer songsWg.Done()
  limit := 1
  options := spotify.Options{Limit: &limit}
  results, err := client.SearchOpt(searchQuery, spotify.SearchTypeTrack, &options)
  if err != nil {
    tracks[index] = ""
    return
  }
  resultTracks := results.Tracks.Tracks
  if len(resultTracks) > 0 {
    trackId := resultTracks[0].ID
    tracks[index] = trackId
  }
}

func clearFailuresFromList(list []spotify.ID) []spotify.ID {
  newList := make([]spotify.ID, 0, len(list))
  for _, id := range list {
    if id != "" {
      newList = append(newList, id)
    }
  }
  return newList
}
