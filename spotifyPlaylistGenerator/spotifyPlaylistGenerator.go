package spotifyPlaylistGenerator

import (
	"fmt"
	"sync"
	"time"

	"github.com/snyderks/spotkov/lastFm"
  "github.com/zmb3/spotify"
)

const playlistName = "Generated by Spotkov"
const maxSongLength = 50

var songsWg sync.WaitGroup

func CreatePlaylist(songs []lastFm.Song, client *spotify.Client, userId string) {
	playlistsPage, err := client.GetPlaylistsForUser(userId)
	playlistExists := false
	var playlistId spotify.ID
	if err == nil {
		playlists := playlistsPage.Playlists
		for _, playlist := range playlists {
			if playlist.Name == playlistName {
				playlistId = playlist.ID
				playlistExists = true
				break
			}
		}
		if playlistExists == false {
			playlistCreated, err := client.CreatePlaylistForUser(userId, playlistName, false)
			if err != nil {
				panic(err)
			}
			playlistId = playlistCreated.SimplePlaylist.ID
		}
	} else {
		fmt.Println("Couldn't retrieve the playlists for", userId, "- playlist has not been saved")
		return
	}
	// retrieve tracklist async
	tracks := make([]spotify.ID, len(songs))
	for i, song := range songs {
		songsWg.Add(1)
		go searchAndAddTrackToList(client, song.Title, song.Artist, tracks, i)
	}
	songsWg.Wait()
	tracks = clearFailuresFromList(tracks)
	if len(tracks) <= maxSongLength {
		err := client.ReplacePlaylistTracks(userId, playlistId, tracks...)
		if err != nil {
			fmt.Println("Couldn't clear and update the playlist. No changes have been made.")
			panic(err)
		}
		fmt.Println("Successfully created the playlist under the name", playlistName)
	} else {
		chunks := len(tracks)/maxSongLength + 1
		trackChunks := make([][]spotify.ID, 0)
		for i := 0; i < chunks; i++ {
			if maxSongLength*(i+1) > len(tracks) {
				trackChunks = append(trackChunks, tracks[maxSongLength*i:])
			} else {
				trackChunks = append(trackChunks, tracks[maxSongLength*i:maxSongLength*(i+1)])
			}
		}
		for i, trackChunk := range trackChunks {
			attempts := 0
			maxAttempts := 100
			if i == 0 {
				err := client.ReplacePlaylistTracks(userId, playlistId, trackChunk...)
				for err != nil {
					if attempts >= maxAttempts {
						fmt.Println("Couldn't clear and update the playlist. No changes have been made.")
						break
					}
					time.Sleep(500 * time.Millisecond)
					err = client.ReplacePlaylistTracks(userId, playlistId, trackChunk...)
					attempts += 1
				}
			} else {
				_, err := client.AddTracksToPlaylist(userId, playlistId, trackChunk...)
				for err != nil {
					if attempts >= maxAttempts {
						fmt.Println("Adding some tracks failed. The playlist contains at least 50 tracks.")
					}
					time.Sleep(500 * time.Millisecond)
					_, err = client.AddTracksToPlaylist(userId, playlistId, trackChunk...)
					attempts += 1
				}
			}
		}
		fmt.Println("Successfully created the playlist under the name", playlistName)
	}

}

func searchAndAddTrackToList(client *spotify.Client, title string, artist string, tracks []spotify.ID, index int) {
	defer songsWg.Done()
	limit := 1
	options := spotify.Options{Limit: &limit}
	query := "track:" + title + " artist:" + artist
	results, err := client.SearchOpt(query, spotify.SearchTypeTrack, &options)
	for err != nil {
		time.Sleep(250 * time.Millisecond)
		results, err = client.SearchOpt(query, spotify.SearchTypeTrack, &options)
	}
	resultTracks := results.Tracks.Tracks
	if len(resultTracks) > 0 {
		trackId := resultTracks[0].ID
		tracks[index] = trackId
	}
}

func clearFailuresFromList(list []spotify.ID) []spotify.ID {
	newList := make([]spotify.ID, 0, len(list))
	for _, id := range list {
		if id != "" {
			newList = append(newList, id)
		}
	}
	return newList
}
