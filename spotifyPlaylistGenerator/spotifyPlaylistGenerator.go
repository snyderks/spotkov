package spotifyPlaylistGenerator

import (
	"encoding/gob"
	"fmt"
	"os"
	"sync"
	"time"

	"github.com/snyderks/spotkov/lastFm"
	"github.com/zmb3/spotify"
)

const playlistName = "Generated by Spotkov"
const maxSongLength = 50

var songsWg sync.WaitGroup

// songIDs is a map of known songs that is safe for use with goroutines
// with the embedded mutex.
type songIDs struct {
	sync.RWMutex
	M map[songAndArtist]spotify.ID
}

var IDs songIDs

// songAndArtist is used as a key for a map
// to organize song IDs with.
type songAndArtist struct {
	Title  string
	Artist string
}

func CreatePlaylist(songs []lastFm.Song, client *spotify.Client, userId string) {
	playlistsPage, err := client.GetPlaylistsForUser(userId)
	playlistExists := false
	var playlistId spotify.ID
	if err == nil {
		playlists := playlistsPage.Playlists
		for _, playlist := range playlists {
			if playlist.Name == playlistName {
				playlistId = playlist.ID
				playlistExists = true
				break
			}
		}
		if playlistExists == false {
			playlistCreated, err := client.CreatePlaylistForUser(userId, playlistName, false)
			if err != nil {
				panic(err)
			}
			playlistId = playlistCreated.SimplePlaylist.ID
		}
	} else {
		fmt.Println("Couldn't retrieve the playlists for", userId, "- playlist has not been saved")
		return
	}
	// retrieve tracklist async
	tracks := make([]spotify.ID, len(songs))
	for i, song := range songs {
		songsWg.Add(1)
		go searchAndAddTrackToList(client, song.Title, song.Artist, tracks, i)
	}
	songsWg.Wait()
	tracks = clearFailuresFromList(tracks)
	if len(tracks) <= maxSongLength {
		err := client.ReplacePlaylistTracks(userId, playlistId, tracks...)
		if err != nil {
			fmt.Println("Couldn't clear and update the playlist. No changes have been made.")
			panic(err)
		}
		fmt.Println("Successfully created the playlist under the name", playlistName)
	} else {
		chunks := len(tracks)/maxSongLength + 1
		trackChunks := make([][]spotify.ID, 0)
		for i := 0; i < chunks; i++ {
			if maxSongLength*(i+1) > len(tracks) {
				trackChunks = append(trackChunks, tracks[maxSongLength*i:])
			} else {
				trackChunks = append(trackChunks, tracks[maxSongLength*i:maxSongLength*(i+1)])
			}
		}
		for i, trackChunk := range trackChunks {
			attempts := 0
			maxAttempts := 100
			if i == 0 {
				err := client.ReplacePlaylistTracks(userId, playlistId, trackChunk...)
				for err != nil {
					if attempts >= maxAttempts {
						fmt.Println("Couldn't clear and update the playlist. No changes have been made.")
						break
					}
					time.Sleep(500 * time.Millisecond)
					err = client.ReplacePlaylistTracks(userId, playlistId, trackChunk...)
					attempts += 1
				}
			} else {
				_, err := client.AddTracksToPlaylist(userId, playlistId, trackChunk...)
				for err != nil {
					if attempts >= maxAttempts {
						fmt.Println("Adding some tracks failed. The playlist contains at least 50 tracks.")
					}
					time.Sleep(500 * time.Millisecond)
					_, err = client.AddTracksToPlaylist(userId, playlistId, trackChunk...)
					attempts += 1
				}
			}
		}
		fmt.Println("Successfully created the playlist under the name", playlistName)
		// save back the known songs
		cacheSongIDs(IDs.M)
	}

}

func searchAndAddTrackToList(client *spotify.Client, title string, artist string, tracks []spotify.ID, index int) {
	defer songsWg.Done()

	// check if there's already a known ID for this song
	// read lock the map
	IDs.RLock()
	id, in := IDs.M[songAndArtist{title, artist}]
	IDs.RUnlock()

	if in {
		tracks[index] = id
	} else {
		// only want one result
		limit := 1
		options := spotify.Options{Limit: &limit}
		query := "track:" + title + " artist:" + artist
		results, err := client.SearchOpt(query, spotify.SearchTypeTrack, &options)
		// keep retrying until there's a response
		for err != nil {
			fmt.Println("Failed on searching for track:" + title)
			time.Sleep(250 * time.Millisecond)
			results, err = client.SearchOpt(query, spotify.SearchTypeTrack, &options)
		}
		resultTracks := results.Tracks.Tracks
		if len(resultTracks) > 0 {
			trackID := resultTracks[0].ID
			tracks[index] = trackID
			// save the ID in the known list
			// lock and unlock with the embedded mutex
			IDs.Lock()
			IDs.M[songAndArtist{title, artist}] = trackID
			IDs.Unlock()
		}
	}
}

func clearFailuresFromList(list []spotify.ID) []spotify.ID {
	newList := make([]spotify.ID, 0, len(list))
	for _, id := range list {
		if id != "" {
			newList = append(newList, id)
		}
	}
	return newList
}

// readCachedSongIDs takes in a map[songAndArtist]spotify.ID object and reads in the
// cached (on filesystem) list of known IDs for Spotify songs. Uses maps for fast lookup.
func readCachedSongIDs(songs interface{}) error {
	file, err := os.Open("songIDs" + ".gob")
	if err == nil {
		decoder := gob.NewDecoder(file)
		err = decoder.Decode(songs)
	}
	file.Close()
	return err
}

func cacheSongIDs(songs map[songAndArtist]spotify.ID) error {
	// for now, hardcoding the file cache.
	file, err := os.Create("songIDs" + ".gob")
	if err == nil {
		encoder := gob.NewEncoder(file)
		encoder.Encode(songs)
	}
	file.Close()
	return err
}

func init() {
	IDs = songIDs{M: make(map[songAndArtist]spotify.ID)}
	// pull all of the known songs.
	readCachedSongIDs(IDs.M)
}
